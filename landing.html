<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Landing — collecte auto (ntfy compatible)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;padding:18px;max-width:920px;margin:auto}
    pre{background:#f6f8fa;padding:12px;border-radius:8px;overflow:auto;white-space:pre-wrap}
    .muted{color:#6b7280;font-size:13px}
    .note{background:#fff7d6;border:1px solid #fde68a;padding:8px;border-radius:8px;margin-bottom:12px}
  </style>
</head>
<body>
  <div class="note">
    Cette page collecte automatiquement des informations techniques non privées (UA, modèle si exposé, écran, réseau, IP publique, etc.).  
    Elle <b>ne</b> récupère pas la géolocalisation fine ni le nom du téléphone sans permission (ajoute <code>&geo=1</code> si tu veux demander la géoloc).
  </div>

  <h1>Scan reçu — collecte automatique</h1>
  <p><b>Statut :</b> <span id="status">initialisation…</span></p>
  <pre id="dump">préparation…</pre>

<script>
/* ====================== CONFIG DEFAULTS ======================
 Replace these defaults if you want built-in values.
 You can also override via URL params:
  - wh = webhook URL (ex: https://webhook.site/XXXX)
  - topic = ntfy topic (ex: qr-scann-test-1)
  - autosend = 1 or 0
  - geo = 1 to request geolocation (will show browser popup)
============================================================= */
const DEFAULT_WEBHOOK_URL = 'https://webhook.site/3ff17bc2-1614-47e8-a254-77fd25e86dda';
const DEFAULT_NTFY_TOPIC  = 'maison';
/* =========================================================== */

const $ = s => document.querySelector(s);
const setStatus = t => { $('#status').textContent = t; };
const showDump = o => { $('#dump').textContent = JSON.stringify(o, null, 2); };

const qs = new URLSearchParams(location.search);
const WEBHOOK_URL = qs.get('wh') || DEFAULT_WEBHOOK_URL;
const NTFY_TOPIC  = qs.get('topic') || DEFAULT_NTFY_TOPIC;
const AUTO_SEND   = (qs.get('autosend') ?? '1') !== '0'; // default on
const WANT_GEO    = (qs.get('geo') ?? '0') === '1';      // default off

/* ---------------- util ---------------- */
function randId(len=10){
  const chars='abcdef0123456789';
  let out='';
  for(let i=0;i<len;i++) out+=chars[Math.floor(Math.random()*chars.length)];
  return out;
}

/* Collecte non-intrusive d'infos (sans permissions) */
async function collectClientInfo({allowGeo=false} = {}){
  const info = {};
  info.ts = new Date().toISOString();
  info.scan_id = randId(12);
  info.url = location.href;
  info.referrer = document.referrer || null;

  // navigator basics
  info.userAgent = navigator.userAgent || null;
  info.language = navigator.language || null;
  info.languages = navigator.languages || null;
  info.platform = navigator.platform || null;
  info.vendor = navigator.vendor || null;
  info.cookieEnabled = navigator.cookieEnabled;
  info.doNotTrack = navigator.doNotTrack || navigator.msDoNotTrack || null;

  // screen / viewport
  info.screen = {
    width: screen.width, height: screen.height,
    availWidth: screen.availWidth, availHeight: screen.availHeight,
    colorDepth: screen.colorDepth
  };
  info.viewport = { innerWidth: innerWidth, innerHeight: innerHeight, devicePixelRatio: window.devicePixelRatio };

  // device heuristics
  info.device = {
    hardwareConcurrency: navigator.hardwareConcurrency || null,
    deviceMemory: navigator.deviceMemory || null,
    maxTouchPoints: navigator.maxTouchPoints || 0
  };

  // UA Client Hints (non-intrusive)
  try {
    if (navigator.userAgentData) {
      info.uaData = { mobile: navigator.userAgentData.mobile ?? null, brands: navigator.userAgentData.brands ?? null };
      if (navigator.userAgentData.getHighEntropyValues) {
        try {
          const high = await navigator.userAgentData.getHighEntropyValues(['platform','platformVersion','model','architecture','bitness','fullVersionList']);
          info.uaData.highEntropy = high;
        } catch(e){
          info.uaData.highEntropyError = String(e);
        }
      }
    }
  } catch(e){ info.uaDataError = String(e); }

  // connection
  try {
    const c = navigator.connection || navigator.mozConnection || navigator.webkitConnection || null;
    if (c) info.connection = { effectiveType: c.effectiveType || null, downlink: c.downlink || null, rtt: c.rtt || null, saveData: c.saveData || null };
  } catch(e){}

  // battery
  try {
    if (navigator.getBattery) {
      const bat = await navigator.getBattery();
      info.battery = { charging: bat.charging, level: bat.level, chargingTime: bat.chargingTime, dischargingTime: bat.dischargingTime };
    }
  } catch(e){ info.batteryError = String(e); }

  // storage estimate
  try {
    if (navigator.storage && navigator.storage.estimate) {
      const est = await navigator.storage.estimate();
      info.storageEstimate = { quota: est.quota || null, usage: est.usage || null };
    }
  } catch(e){}

  // webgl info
  try {
    const c = document.createElement('canvas');
    const gl = c.getContext('webgl') || c.getContext('experimental-webgl');
    if (gl) {
      const debug = gl.getExtension('WEBGL_debug_renderer_info');
      info.webgl = {
        vendor: debug ? gl.getParameter(debug.UNMASKED_VENDOR_WEBGL) : gl.getParameter(gl.VENDOR),
        renderer: debug ? gl.getParameter(debug.UNMASKED_RENDERER_WEBGL) : gl.getParameter(gl.RENDERER)
      };
    }
  } catch(e){ info.webglError = String(e); }

  // mimeTypes
  try { info.mimeTypes = Array.from(navigator.mimeTypes || []).map(m=>({type:m.type,desc:m.description})); } catch(e){}

  // permissions status (query does NOT trigger popups)
  try {
    if (navigator.permissions && navigator.permissions.query) {
      const names = ['geolocation','camera','microphone','notifications'];
      info.permissions = {};
      await Promise.all(names.map(async n=>{
        try{
          const s = await navigator.permissions.query({ name: n });
          info.permissions[n] = s.state; // granted/denied/prompt
        } catch(e){
          info.permissions[n] = 'unsupported';
        }
      }));
    }
  } catch(e){ info.permissionsError = String(e); }

  // enumerate media devices -> counts (labels empty unless permission)
  try {
    if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
      const list = await navigator.mediaDevices.enumerateDevices();
      info.mediaDevices = {
        total: list.length,
        counts: list.reduce((acc,d)=>{ acc[d.kind]=(acc[d.kind]||0)+1; return acc; }, {})
      };
    }
  } catch(e){ info.mediaDevicesError = String(e); }

  // audio context sample rate
  try {
    const AC = window.AudioContext || window.webkitAudioContext;
    if (AC) {
      const ac = new AC();
      info.audio = { sampleRate: ac.sampleRate };
      ac.close && ac.close();
    }
  } catch(e){}

  // IP + basic geo via external services (ipapi.co, fallback ipwho.is)
  try {
    let ipResp = null;
    try {
      let r = await fetch('https://ipapi.co/json/', {cache:'no-store'}); if (r.ok) ipResp = await r.json();
    } catch(e){}
    if(!ipResp){
      try { let r2 = await fetch('https://ipwho.is/', {cache:'no-store'}); if (r2.ok) ipResp = await r2.json(); } catch(e){}
    }
    if (ipResp) {
      info.ip = ipResp.ip || ipResp.client_ip || null;
      info.ip_geo = ipResp;
    } else {
      info.ip = null;
      info.ip_geo = null;
    }
  } catch(e){ info.ipError = String(e); }

  // geolocation prompt only if allowed by parameter
  if (allowGeo && navigator.geolocation) {
    info.geolocationPrompted = true;
    try {
      await new Promise(resolve => {
        navigator.geolocation.getCurrentPosition(pos=>{
          info.geolocation = { lat: pos.coords.latitude, lon: pos.coords.longitude, accuracy: pos.coords.accuracy };
          resolve();
        }, err=>{
          info.geolocation = { error: err.message || String(err.code) };
          resolve();
        }, { enableHighAccuracy:false, timeout:10000, maximumAge:60000 });
      });
    } catch(e){ info.geolocationError = String(e); }
  } else {
    info.geolocationPrompted = false;
  }

  return info;
}

/* POST JSON helper */
async function postJSON(url, obj){
  try {
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(obj)
    });
    return { ok: res.ok, status: res.status, text: await res.text().catch(()=>'' ) };
  } catch(e) { return { ok:false, error:String(e) }; }
}

/* ---------- SIMPLE ntfy sender (no custom headers) ----------
   Uses a plain text POST to avoid preflight CORS issues.
   The message will appear on https://ntfy.sh/<topic>
-------------------------------------------------------------- */
async function sendNtfySimple(topic, titleLines, clickUrl=null){
  try {
    const body = [
      `[QR] ${titleLines[0] || 'QR scan'}`,
      ...(clickUrl ? [`(Open log: ${clickUrl})`] : []),
      '---',
      ...titleLines.slice(1)
    ].join('\n');

    const res = await fetch(`https://ntfy.sh/${encodeURIComponent(topic)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'text/plain; charset=utf-8' }, // simple request -> no preflight
      body
    });
    return { ok: res.ok, status: res.status };
  } catch(e) {
    console.error('ntfy send error', e);
    return { ok:false, error:String(e) };
  }
}

/* small summary for ntfy */
function summarizeForNtfy(info){
  const ua = info.userAgent || '';
  const model = info.uaData?.highEntropy?.model || null;
  const platform = info.uaData?.highEntropy?.platform || info.platform || null;
  const likely =
    /iphone/i.test(ua) ? 'iPhone' :
    /ipad/i.test(ua) ? 'iPad' :
    /android/i.test(ua) ? 'Android' :
    /windows/i.test(ua) ? 'Windows' :
    /mac os|macintosh/i.test(ua) ? 'Mac' : 'Device';

  const brands = info.uaData?.brands ? info.uaData.brands.map(b=>b.brand||b.brandName||'').join(', ') : null;

  const lines = [
    `Scan — ${likely}${model ? ' ('+model+')' : ''}`,
    `IP: ${info.ip || 'n/d'} • ${info.ip_geo?.country || ''} ${info.ip_geo?.city ? '- '+info.ip_geo.city : ''}`,
    `OS: ${platform || 'n/d'} • Browser: ${brands || 'n/d'}`,
    `Screen: ${info.screen?.width || '?'}x${info.screen?.height || '?'} DPR ${info.viewport?.devicePixelRatio || '?'}`,
    info.connection ? `Net: ${info.connection.effectiveType || '?'} ~${info.connection.downlink || '?'}Mbps` : '',
    info.battery ? `Battery: ${Math.round((info.battery.level||0)*100)}% ${info.battery.charging? '(charging)':''}` : '',
    `UA: ${info.userAgent || 'n/d'}`
  ].filter(Boolean);
  return lines;
}

/* ========== main ========== */
let lastPayload = null;

async function runMain(){
  try {
    setStatus('Collecte des données (sans permissions)…');
    const info = await collectClientInfo({ allowGeo: WANT_GEO });
    lastPayload = { event:'qr_scan', timestamp: new Date().toISOString(), scan_url: location.href, client: info };
    showDump(lastPayload);

    if (AUTO_SEND) {
      setStatus('Envoi JSON vers webhook…');
      const r = await postJSON(WEBHOOK_URL, lastPayload);
      if (r.ok) setStatus('Envoyé vers webhook ✅ ('+r.status+')');
      else setStatus('Échec envoi webhook — voir console');

      // send simple, no-preflight ntfy message
      setStatus('Envoi résumé vers ntfy (simple)…');
      const lines = summarizeForNtfy(info);
      await sendNtfySimple(NTFY_TOPIC, lines, WEBHOOK_URL);
      setStatus('Notif ntfy envoyée (si réseau le permet) ✅');
    } else {
      setStatus('Collecte terminée — autosend désactivé.');
    }
  } catch(e) {
    console.error(e);
    setStatus('Erreur — voir console.');
  }
}

// start automatically
runMain();

// debugging helper (console)
window._qr_lastPayload = () => lastPayload;
</script>
</body>
</html>
